{"version":3,"file":"././js//app.es5.js","mappings":"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","sources":["webpack://jamiedraws/../shared/ts/utils/html.ts","webpack://jamiedraws/../shared/ts/observers/intersection.ts","webpack://jamiedraws/../shared/ts/components/carousel.ts","webpack://jamiedraws/../shared/ts/components/fade-carousel.ts","webpack://jamiedraws/../shared/ts/api/carousel/slide/slide.ts","webpack://jamiedraws/../shared/ts/api/carousel/slide/adapters/slide-carousel.ts","webpack://jamiedraws/../shared/ts/api/carousel/slide/adapters/fade-slide-carousel.ts","webpack://jamiedraws/./js/app.ts"],"sourcesContent":["import * as Data from \"Shared/ts/utils/data\";\r\n\r\nexport type HTMLList =\r\n    | Element\r\n    | NodeList\r\n    | NodeListOf<HTMLElement>\r\n    | NodeListOf<Element>\r\n    | HTMLCollectionOf<Element>;\r\n\r\nexport type HTMLItem = HTMLElement | Node;\r\n\r\nconst div: HTMLElement = document.createElement(\"div\");\r\n\r\n/**\r\n * createElement takes a string tag name along with an optional object of attributes and returns a new HTMLElement.\r\n * @param tag string\r\n * @param attributes object\r\n * @return HTMLElement\r\n */\r\nexport const createElement = <T extends {}>(\r\n    tag: string,\r\n    attributes?: T\r\n): HTMLElement => {\r\n    const element = document.createElement(tag);\r\n\r\n    return setElementAttributes(element, attributes);\r\n};\r\n\r\n/**\r\n * Takes an object representing an attribute key-value pair and assigns it to an HTMLElement. The HTMLElement will be returned.\r\n * @param element HTMLElement\r\n * @param attributes T\r\n * @returns HTMLElement\r\n */\r\nexport const setElementAttributes = <T extends { [key: string]: any }>(\r\n    element: HTMLElement,\r\n    attributes?: T\r\n): HTMLElement => {\r\n    if (attributes && Data.isObject(attributes)) {\r\n        Object.keys(attributes).forEach((attribute) => {\r\n            element.setAttribute(attribute, attributes[attribute]);\r\n        });\r\n    }\r\n\r\n    return element;\r\n};\r\n\r\n/**\r\n * Takes a string representing an HTML template and converts it into a document fragment. The document fragment is returned.\r\n * @param template string\r\n * @returns DocumentFragment\r\n */\r\nexport const renderTemplate = (template: string): DocumentFragment => {\r\n    const range = document.createRange();\r\n\r\n    return range.createContextualFragment(template);\r\n};\r\n\r\n/**\r\n * Takes a document fragment and converts it into an HTML element. The Element is returned.\r\n * @param fragment DocumentFragment\r\n * @returns Element | null\r\n */\r\nexport const convertFragmentToHTMLElement = (\r\n    fragment: DocumentFragment\r\n): Element | null => {\r\n    div.appendChild(fragment);\r\n\r\n    return div.lastElementChild;\r\n};\r\n\r\n/**\r\n * appendElement takes an HTMLElement and appends it to the document body. The same element is then returned.\r\n * @param element HTMLElement\r\n * @return HTMLElement\r\n */\r\nexport const appendElement = (element: HTMLElement): HTMLElement => {\r\n    document.body.appendChild(element);\r\n\r\n    return element;\r\n};\r\n\r\n/**\r\n * elementExists takes an HTMLItem and will return true if the item exists either in the document body or in the document head.\r\n * @param element HTMLItem\r\n * @return boolean\r\n */\r\nexport const elementExists = (element: HTMLItem | null): boolean => {\r\n    return document.body.contains(element) || document.head.contains(element);\r\n};\r\n\r\n/**\r\n * enumerateElements takes an HTMLList and returns an element array.\r\n * @param elements HTMLList\r\n * @return Element[]\r\n */\r\nexport const enumerateElements = (elements: HTMLList): Element[] => {\r\n    let ar = [].slice.call(elements);\r\n\r\n    return ar;\r\n};\r\n\r\n/**\r\n * Attempts to convert a JSON string value of an HTML attribute into JSON format.\r\n * @param element Element | null\r\n * @param attribute string\r\n * @returns JSON object\r\n */\r\nexport const getJSONByElementAttribute = <T>(\r\n    element: Element | null,\r\n    attribute: string\r\n): T => {\r\n    let json = {} as any;\r\n\r\n    if (!element || !attribute) return json;\r\n\r\n    try {\r\n        const value = element.getAttribute(attribute);\r\n        json = value !== null ? JSON.parse(value) : json;\r\n    } catch (e: unknown) {\r\n        const message = e instanceof Error ? e.message : String(e);\r\n        console.debug(message);\r\n    }\r\n\r\n    return json;\r\n};\r\n","import { isFunction } from \"Shared/ts/utils/data\";\r\nimport { enumerateElements } from \"Shared/ts/utils/html\";\r\n\r\n/**\r\n * IntersectionObserverConfig allows an optional inRange callback function to execute when an element intersects inside the viewport, allows an optional outRange callback function to execute when an element intersects outside the viewport, an optional boolean to unobserve elements and an optional configuration object to customize the Intersection Observer API behavior.\r\n */\r\nexport interface IntersectionObserverConfig {\r\n    /**\r\n     * Callback fires when an element intersects the viewport\r\n     */\r\n    inRange?: (record: Element, observer?: IntersectionObserverEntry) => void;\r\n    /**\r\n     * Callback fires when an element leaves the viewport\r\n     */\r\n    outRange?: (record: Element, observer?: IntersectionObserverEntry) => void;\r\n    /**\r\n     * Determines whether the element should be unobserved immediately after it's been observed the first time. Defaults to true.\r\n     */\r\n    unObserve?: boolean;\r\n    /**\r\n     * Represents the Intersection Observer initialization object that will be provided through a new Intersection Observer instance. Note that this object will not apply on browsers that do not support the Intersection Observer Api.\r\n     */\r\n    options?: IntersectionObserverInit;\r\n}\r\n\r\n/**\r\n * Handles observation of load items through the bounding client rectangle interface. This process will be used if the current browser does not support the Intersection Observer Api.\r\n * @param loadItems Element[]\r\n * @param config IntersectionObserverConfig\r\n */\r\nconst observeByBoundingClientRect = (\r\n    loadItems: Element[],\r\n    config: IntersectionObserverConfig\r\n) => {\r\n    let active = false;\r\n\r\n    const process = () => {\r\n        if (active === false) {\r\n            active = true;\r\n\r\n            setTimeout(() => {\r\n                loadItems.forEach((loadItem) => {\r\n                    if (inView(loadItem as HTMLElement)) {\r\n                        config?.inRange?.(loadItem);\r\n\r\n                        if (config?.unObserve ?? true) {\r\n                            loadItems = loadItems.filter((image) => {\r\n                                return image !== loadItem;\r\n                            });\r\n\r\n                            if (loadItems.length === 0) {\r\n                                document.removeEventListener(\"scroll\", process);\r\n                                window.removeEventListener(\"resize\", process);\r\n                                window.removeEventListener(\r\n                                    \"orientationchange\",\r\n                                    process\r\n                                );\r\n                            }\r\n                        }\r\n                    } else {\r\n                        config?.outRange?.(loadItem);\r\n                    }\r\n                });\r\n\r\n                active = false;\r\n            }, 200);\r\n        }\r\n    };\r\n\r\n    document.addEventListener(\"scroll\", process);\r\n    window.addEventListener(\"resize\", process);\r\n    window.addEventListener(\"orientationchange\", process);\r\n    window.addEventListener(\"DOMContentLoaded\", process);\r\n};\r\n\r\n/**\r\n * Determines if the element is in the viewport and is visible based on it's display state and it's bounding client rectangle coordinates.\r\n * @param loadItem HTMLElement\r\n * @returns boolean\r\n */\r\nconst inView = (loadItem: HTMLElement): boolean => {\r\n    return (\r\n        loadItem.getBoundingClientRect().top <= window.innerHeight &&\r\n        loadItem.getBoundingClientRect().bottom >= 0 &&\r\n        loadItem.style.display !== \"none\"\r\n    );\r\n};\r\n\r\n/**\r\n * Handles observeration of load item elements through the Intersection Observer Api\r\n * @param loadItems Element[]\r\n * @param config IntersectionObserverConfig\r\n */\r\nconst observeByApi = (\r\n    loadItems: Element[],\r\n    config: IntersectionObserverConfig\r\n) => {\r\n    const loadItemObserver = new IntersectionObserver((entries) => {\r\n        entries.forEach((entry) => {\r\n            if (entry.intersectionRatio > 0 && entry.isIntersecting) {\r\n                config?.inRange?.(entry.target, entry);\r\n                if (config?.unObserve ?? true) {\r\n                    loadItemObserver.unobserve(entry.target);\r\n                }\r\n            } else {\r\n                config?.outRange?.(entry.target, entry);\r\n            }\r\n        });\r\n    }, config?.options);\r\n\r\n    loadItems.forEach(function (loadItem) {\r\n        loadItemObserver.observe(loadItem);\r\n    });\r\n};\r\n\r\n/**\r\n * Observer applies a string that represents a Document Element and observes when the element intersects in and out of the browser viewport. Optional configuration is provided through the IntersectionObserverConfig interface.\r\n * @param selector string = \"[data-observe]\"\r\n * @param config IntersectionObserverConfig\r\n */\r\nexport const observer = (\r\n    selector: string = \"[data-observe]\",\r\n    config?: IntersectionObserverConfig\r\n): void => {\r\n    let loadItems = enumerateElements(document.querySelectorAll(selector));\r\n\r\n    if (!config) return;\r\n\r\n    if (\"IntersectionObserver\" in window) {\r\n        observeByApi(loadItems, config);\r\n    } else {\r\n        observeByBoundingClientRect(loadItems, config);\r\n    }\r\n};\r\n","import ICarousel from \"Shared/ts/interfaces/carousel/carousel\";\r\nimport {\r\n    ICarouselEvent,\r\n    ICarouselConfig,\r\n    ICarouselControls\r\n} from \"Shared/ts/interfaces/carousel/carousel\";\r\nimport { observer } from \"Shared/ts/observers/intersection\";\r\nimport { enumerateElements } from \"Shared/ts/utils/html\";\r\n\r\nexport default class Carousel {\r\n    /**\r\n     * Represents the CSS class name for the selected thumbnail button\r\n     */\r\n    private static currentThumbnailCSSClassName: string =\r\n        \"slide__thumbnail--is-selected\";\r\n\r\n    /**\r\n     * Represents the relationship between the carousel's container element and it's connected Carousel interface\r\n     */\r\n    protected static context: WeakMap<Element, ICarousel> = new WeakMap();\r\n\r\n    /**\r\n     * Represents the relationship between the carousel's container element and it's connected event interface\r\n     */\r\n    private static events: WeakMap<Element, ICarouselEvent[]> = new WeakMap();\r\n\r\n    /**\r\n     * Represents the relationship between the carousel's container element and it's connected control interface\r\n     */\r\n    protected static controls: WeakMap<Element, ICarouselControls> =\r\n        new WeakMap();\r\n\r\n    private static thumbnails: WeakMap<Element, Element[]> = new WeakMap();\r\n\r\n    /**\r\n     * Represents the element containing the carousel along with other user-interface components\r\n     */\r\n    public container: Element | undefined;\r\n\r\n    /**\r\n     * Takes a carousel interface and integrates it with basic play controls\r\n     * @param context ICarousel\r\n     */\r\n    constructor(context: ICarousel) {\r\n        this.container = context.container;\r\n\r\n        Carousel.baseInitialize(context, this);\r\n        Carousel.observeContainer(context, this);\r\n    }\r\n\r\n    /**\r\n     * Takes the ICarousel interface and uses the container element as a key to establish a new context to the interface. Next, a new watch callback is established that will notify observers on each rotation.\r\n     * @param context ICarousel\r\n     */\r\n    private static baseInitialize(context: ICarousel, carousel: Carousel) {\r\n        if (!context.container) return;\r\n\r\n        Carousel.context.set(context.container, context);\r\n        Carousel.events.set(context.container, []);\r\n\r\n        context.watch(() => {\r\n            Carousel.push(context, \"rotation\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Filters through all events matching a specified name and invokes the handler callback function\r\n     * @param context ICarousel\r\n     * @param name string\r\n     */\r\n    protected static push(context: ICarousel, name: string): void {\r\n        if (!context.container) return;\r\n\r\n        const events = Carousel.events.get(context.container);\r\n        if (!events) return;\r\n\r\n        events\r\n            .filter((event) => event.name === name)\r\n            .forEach((event) =>\r\n                event.handler(\r\n                    context.currentIndex(),\r\n                    context.prevIndex(),\r\n                    context.nextIndex()\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Adds an event to be captured where a handler callback function can be invoked\r\n     * @param name string\r\n     * @param handler function\r\n     */\r\n    public on(\r\n        name: string,\r\n        handler: (\r\n            currentIndex: number | undefined,\r\n            prevIndex: number | undefined,\r\n            nextIndex: number | undefined\r\n        ) => void\r\n    ): void {\r\n        if (!this.container) return;\r\n\r\n        const events = Carousel.events.get(this.container);\r\n        if (!events) return;\r\n\r\n        events.push({\r\n            name: name,\r\n            handler: handler\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes an event from being captured\r\n     * @param name string\r\n     * @param handler function\r\n     */\r\n    public off(\r\n        name: string,\r\n        handler: (\r\n            currentIndex: number,\r\n            prevIndex: number,\r\n            nextIndex: number\r\n        ) => void\r\n    ): void {\r\n        if (!this.container) return;\r\n\r\n        const events = Carousel.events.get(this.container);\r\n        if (!events) return;\r\n\r\n        const result = events.find(\r\n            (event) => event.name === name && event.handler === handler\r\n        );\r\n        if (!result) return;\r\n\r\n        const index = events.indexOf(result);\r\n\r\n        events.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Takes the carousel's container element as a key to look up it's connected carousel interface and returns the interface.\r\n     * @param container Element\r\n     * @returns ICarousel\r\n     */\r\n    protected static getContext(container: Element): ICarousel | undefined {\r\n        return this.context.get(container);\r\n    }\r\n\r\n    /**\r\n     * Takes the ICarousel interface and reads in any available key-value pairs from the \"data-carousel-config\" HTML attribute into an attribute processor.\r\n     * @param context ICarousel\r\n     */\r\n    private static updateAttributes(\r\n        context: ICarousel,\r\n        carousel: Carousel\r\n    ): void {\r\n        if (!context.container) return;\r\n\r\n        const config = context.container.getAttribute(\"data-carousel-config\");\r\n\r\n        if (config) {\r\n            try {\r\n                carousel.processAttributes(JSON.parse(config), context);\r\n            } catch (error) {\r\n                console.warn(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes the ICarouselConfig interface and converts key-value pairs into a string representation of the carousel configuration. This configuration replaces the previous configuration on data-carousel-config attribute.\r\n     * @param config ICarouselConfig\r\n     */\r\n    public setAttributes(config: ICarouselConfig): void {\r\n        const container = this.container as HTMLElement;\r\n\r\n        try {\r\n            container.dataset.carouselConfig = JSON.stringify(config);\r\n        } catch (error) {\r\n            console.warn(error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes an ICarouselConfig interface along with an ICarousel interface and processes specific keys to operate using its values\r\n     * @param config ICarouselConfig\r\n     * @param context ICarousel\r\n     */\r\n    protected processAttributes(\r\n        config: ICarouselConfig,\r\n        context: ICarousel\r\n    ): void {\r\n        if (config.auto) {\r\n            context.setAuto(config.auto);\r\n        }\r\n\r\n        if (config.delay) {\r\n            context.setDelay(config.delay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes the ICarousel interface, creates a new mutation observer on the container element and observes for attribute changes which will call the updateAttributes method\r\n     * @param context ICarousel\r\n     */\r\n    private static observeContainer(context: ICarousel, carousel: Carousel) {\r\n        if (!context.container) return;\r\n\r\n        this.updateAttributes(context, carousel);\r\n\r\n        const observer = new MutationObserver((mutationRecords) => {\r\n            Carousel.updateAttributes(context, carousel);\r\n        });\r\n\r\n        observer.observe(context.container, {\r\n            attributes: true\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Navigates to a designated slide.\r\n     * @param index number\r\n     */\r\n    public goto(index: number): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        context.goto(index);\r\n    }\r\n\r\n    /**\r\n     * Plays the carousel continuously.\r\n     */\r\n    public play(persistCurrentIndex?: boolean): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        context.play(persistCurrentIndex);\r\n    }\r\n\r\n    /**\r\n     * Pauses the carousel\r\n     */\r\n    public pause(): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        context.pause();\r\n    }\r\n\r\n    /**\r\n     * Advances the carousel to the next slide\r\n     */\r\n    public next(): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        context.next();\r\n    }\r\n\r\n    /**\r\n     * Advances the carousel to the previous slide\r\n     */\r\n    public prev(): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        context.prev();\r\n    }\r\n\r\n    /**\r\n     * Enables the carousel to play continuously when the carousel's container element intersects the viewport; otherwise, the carousel will automatically pause.\r\n     */\r\n    public autoplay(): void {\r\n        if (!this.container) return;\r\n\r\n        const self = this;\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        const id = context.parent?.id;\r\n\r\n        let rangeControl = false;\r\n\r\n        observer(`#${id}`, {\r\n            inRange: (record) => {\r\n                if (!rangeControl) {\r\n                    rangeControl = true;\r\n\r\n                    self.play(true);\r\n                }\r\n            },\r\n            outRange: (record) => {\r\n                if (rangeControl) {\r\n                    rangeControl = false;\r\n\r\n                    self.pause();\r\n                }\r\n            },\r\n            unObserve: false,\r\n            options: {\r\n                threshold: [0.75]\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables the carousel to activate the previous and next methods through user-interface components\r\n     */\r\n    public enablePrevNextControls(): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        const prevButton = context.container?.querySelector(\".slide__prev\");\r\n        const nextButton = context.container?.querySelector(\".slide__next\");\r\n\r\n        prevButton?.addEventListener(\"click\", this.prev.bind(context));\r\n        nextButton?.addEventListener(\"click\", this.next.bind(context));\r\n    }\r\n\r\n    /**\r\n     * Enables the carousel to activate the play and pause methods through user-interface components\r\n     */\r\n    public enablePlayPauseControls(): void {\r\n        if (!this.container) return;\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        const playButton = context.container?.querySelector(\".slide__play\");\r\n        const pauseButton = context.container?.querySelector(\".slide__pause\");\r\n\r\n        playButton?.addEventListener(\"click\", (event) => this.play());\r\n        pauseButton?.addEventListener(\"click\", this.pause.bind(context));\r\n    }\r\n\r\n    /**\r\n     * Uses the array of thumbnail buttons to locate the previous button with the thumbnail CSS class name and removes it. Then, assigns the CSS class name to the current thumbnail button.\r\n     * @param thumbnailButton Element\r\n     * @param thumbnailButtons Element[]\r\n     */\r\n    protected static updateThumbnailNavigationMarker(\r\n        thumbnailButton: Element,\r\n        thumbnailButtons: Element[]\r\n    ): void {\r\n        const previousButton = thumbnailButtons.find((thumbnailButton) =>\r\n            thumbnailButton.classList.contains(\r\n                Carousel.currentThumbnailCSSClassName\r\n            )\r\n        );\r\n\r\n        if (previousButton) {\r\n            previousButton.classList.remove(\r\n                Carousel.currentThumbnailCSSClassName\r\n            );\r\n        }\r\n\r\n        if (thumbnailButton) {\r\n            thumbnailButton.classList.add(\r\n                Carousel.currentThumbnailCSSClassName\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes an thumbnailButton element and extracts the index value from it and navigates the carousel to the specified index\r\n     * @param thumbnailButton Element\r\n     * @param context ICarousel\r\n     */\r\n    protected static updateThumbnailNavigation(\r\n        thumbnailButton: Element,\r\n        context: Carousel\r\n    ): void {\r\n        const index = parseInt(\r\n            thumbnailButton.getAttribute(\"data-slide-index\") ?? \"\"\r\n        );\r\n\r\n        context.goto(index);\r\n    }\r\n\r\n    /**\r\n     * Uses an index number to target a specific thumbnailButton element and then updates the thumbnail navigation marker with that element\r\n     * @param index number\r\n     * @param context ICarousel\r\n     */\r\n    protected static updateThumbnailNavigationMarkerByIndex(\r\n        index: number,\r\n        context: ICarousel\r\n    ): void {\r\n        if (!context.container) return;\r\n\r\n        const hasThumbnailButtons = Carousel.thumbnails.has(context.container);\r\n\r\n        if (hasThumbnailButtons) {\r\n            const thumbnailButtons = Carousel.thumbnails.get(context.container);\r\n\r\n            const currentButton = thumbnailButtons?.find(\r\n                (thumbnailButton) =>\r\n                    parseInt(\r\n                        thumbnailButton.getAttribute(\"data-slide-index\") ?? \"\"\r\n                    ) === index\r\n            );\r\n\r\n            if (!currentButton || !thumbnailButtons) return;\r\n\r\n            Carousel.updateThumbnailNavigationMarker(\r\n                currentButton,\r\n                thumbnailButtons\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the carousel to activate thumbnail controls through user-interface components\r\n     */\r\n    public enableThumbnailControls(\r\n        eventCallback?: (event: Event) => void\r\n    ): void {\r\n        if (!this.container) return;\r\n\r\n        const thumbnailButtons = enumerateElements(\r\n            this.container.querySelectorAll(\".slide__thumbnail\")\r\n        );\r\n\r\n        Carousel.thumbnails.set(this.container, thumbnailButtons);\r\n\r\n        thumbnailButtons.forEach((thumbnailButton) => {\r\n            thumbnailButton.addEventListener(\"click\", (event) => {\r\n                const currentButton = event.target as Element;\r\n\r\n                Carousel.updateThumbnailNavigation(currentButton, this);\r\n                Carousel.updateThumbnailNavigationMarker(\r\n                    currentButton,\r\n                    thumbnailButtons\r\n                );\r\n\r\n                if (typeof eventCallback === \"function\") eventCallback(event);\r\n            });\r\n        });\r\n\r\n        const context = Carousel.getContext(this.container);\r\n        if (!context) return;\r\n\r\n        this.on(\"rotation\", (currentIndex) => {\r\n            if (currentIndex === undefined) return;\r\n\r\n            Carousel.updateThumbnailNavigationMarkerByIndex(\r\n                currentIndex,\r\n                context\r\n            );\r\n        });\r\n    }\r\n}\r\n","import Carousel from \"Shared/ts/components/carousel\";\r\nimport IFadeCarousel from \"Shared/ts/interfaces/carousel/fade-carousel\";\r\nimport { elementExists } from \"Shared/ts/utils/html\";\r\n\r\nexport default class FadeCarousel extends Carousel {\r\n    /**\r\n     * Represents the current slide CSS class name\r\n     */\r\n    private static currentSlideCSSClassName: string = \"slide__item--current\";\r\n\r\n    /**\r\n     * Extends the Carousel's base functionality by visually animating it as a fader.\r\n     * @param elements HTMLList\r\n     */\r\n    constructor(context: IFadeCarousel) {\r\n        super(context);\r\n\r\n        FadeCarousel.initialize(context);\r\n    }\r\n\r\n    /**\r\n     * Takes in the FadeCarousel instance and iterates through each element. For each element, the first slide is set as the current slide and a new watch callback function is estabilished.\r\n     * @param context IFadeCarousel\r\n     */\r\n    private static initialize(context: IFadeCarousel): void {\r\n        if (context.children === undefined) return;\r\n\r\n        context.initialize();\r\n\r\n        FadeCarousel.createWatch(context);\r\n        FadeCarousel.setSlideToCurrent(context.children.item(0));\r\n    }\r\n\r\n    /**\r\n     * Takes the Fade Carousel interface context and establishes a new watch callback function that will change on each rotation\r\n     * @param context IFadeCarousel\r\n     */\r\n    private static createWatch(context: IFadeCarousel): void {\r\n        let counter = 1;\r\n        const children = context.countChildren();\r\n\r\n        context.watch((currentIndex) => {\r\n            if (\r\n                context.parent === undefined ||\r\n                context.children === undefined ||\r\n                children === undefined\r\n            )\r\n                return;\r\n\r\n            FadeCarousel.push(context, \"rotation\");\r\n\r\n            if (counter > children) {\r\n                FadeCarousel.updateCurrentSlide(\r\n                    context.parent,\r\n                    context.children.item(currentIndex)\r\n                );\r\n            }\r\n\r\n            if (counter === children) {\r\n                context.setIndex(0);\r\n                FadeCarousel.updateThumbnailNavigationMarkerByIndex(0, context);\r\n            }\r\n\r\n            if (counter <= children) {\r\n                counter++;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Takes the parent and attempts to locate the previous slide and remove the current slide CSS class from it and adds the current slide CSS class to the current slide element.\r\n     * @param parent Element\r\n     * @param slide Element\r\n     */\r\n    private static updateCurrentSlide(\r\n        parent: Element,\r\n        slide: Element | null\r\n    ): void {\r\n        const previousSlide = parent.querySelector(\r\n            `.${this.currentSlideCSSClassName}`\r\n        );\r\n\r\n        if (elementExists(previousSlide)) {\r\n            previousSlide?.classList.remove(this.currentSlideCSSClassName);\r\n        }\r\n\r\n        this.setSlideToCurrent(slide);\r\n    }\r\n\r\n    /**\r\n     * Assigns the current slide CSS class name to the target slide element\r\n     * @param slides Element\r\n     */\r\n    private static setSlideToCurrent(slide: Element | null): void {\r\n        slide?.classList.add(this.currentSlideCSSClassName);\r\n    }\r\n}\r\n","// @ts-nocheck\r\n\r\nimport {\r\n    ISlideApi,\r\n    ISlideOrganization,\r\n    ISlideDefault,\r\n    ISlideWorker\r\n} from \"Shared/ts/interfaces/carousel/slide/slide\";\r\n\r\ntype SlideIntoTask = () => void;\r\n\r\nconst generate = function <P extends {}>(properties: P, o?: {} | undefined) {\r\n    const x = Object.defineProperties(o || {}, properties);\r\n    return x;\r\n};\r\n\r\nconst toArray = function (\r\n    collection: NodeList | HTMLCollection\r\n): (Node | Element)[] {\r\n    return Array.from(collection);\r\n};\r\n\r\nconst slide = generate({\r\n    defaults: {\r\n        value: generate({\r\n            delay: {\r\n                value: 3000\r\n            },\r\n            noScroll: {\r\n                value: \"slide__into--no-scroll\"\r\n            },\r\n            error: {\r\n                value: \"The passed error code could not be found.\"\r\n            }\r\n        })\r\n    },\r\n    docs: {\r\n        value: generate({\r\n            error: {\r\n                value: \"https://github.com/jamiedraws/Slide/wiki/Slide.js#api-errors\"\r\n            }\r\n        })\r\n    },\r\n    errors: {\r\n        value: generate({\r\n            \"ERR-E\": {\r\n                value: \"The passed 'element' must be an element.\"\r\n            },\r\n            \"ERR-P\": {\r\n                value: \"The passed 'element' could not be found.\"\r\n            },\r\n            \"ERR-N\": {\r\n                value: \"The passed 'element' is not a node element.\"\r\n            },\r\n            \"ERR-X\": {\r\n                value: \"The passed 'index' is not a number.\"\r\n            },\r\n            \"ERR-M\": {\r\n                value: \"The passed error 'code' or 'message' is not a string.\"\r\n            },\r\n            \"ERR-C\": {\r\n                value: \"The passed error 'code' is not a string.\"\r\n            }\r\n        })\r\n    },\r\n    team: {\r\n        value: []\r\n    },\r\n    request: {\r\n        value: function (id: string): ISlideWorker {\r\n            return this.team[id];\r\n        }\r\n    },\r\n    observer: {\r\n        value: function (\r\n            parent: Element,\r\n            children: NodeList,\r\n            cb: (index: number) => void\r\n        ) {\r\n            if (window.hasOwnProperty(\"IntersectionObserver\")) {\r\n                const io = new IntersectionObserver(\r\n                    function (entries) {\r\n                        entries.forEach(function (entry) {\r\n                            if (\r\n                                entry.intersectionRatio > 0 &&\r\n                                entry.isIntersecting\r\n                            ) {\r\n                                const items = toArray(children);\r\n                                const index = items.indexOf(entry.target);\r\n\r\n                                cb(index);\r\n                            }\r\n                        });\r\n                    },\r\n                    {\r\n                        root: parent,\r\n                        rootMargin: \"0px\",\r\n                        threshold: 0.9\r\n                    }\r\n                );\r\n\r\n                return function (children: NodeList) {\r\n                    const items = toArray(children);\r\n                    items.forEach(function (item) {\r\n                        io.observe(item as Element);\r\n                    });\r\n                };\r\n            } else {\r\n                return function () {\r\n                    const noScroll = slide.defaults.noScroll;\r\n                    this.shim = true;\r\n                    this.parent.classList.add(noScroll);\r\n                };\r\n            }\r\n        }\r\n    },\r\n    manager: {\r\n        value: generate({\r\n            config: {\r\n                value: function (options: Record<string, any>) {\r\n                    const self = this;\r\n\r\n                    if (typeof options === \"object\") {\r\n                        Object.keys(options).forEach(function (option) {\r\n                            Object.defineProperty(self, option, {\r\n                                enumerable: true,\r\n                                value: options[option]\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            },\r\n            create: {\r\n                value: function (\r\n                    api: ISlideApi,\r\n                    id: string,\r\n                    parent: Element,\r\n                    config\r\n                ) {\r\n                    const self = Object.create(api);\r\n\r\n                    Object.defineProperties(self, {\r\n                        name: {\r\n                            set: function (parent) {\r\n                                this.parent = parent;\r\n                            },\r\n                            get: function () {\r\n                                return this.parent.id;\r\n                            }\r\n                        },\r\n                        id: {\r\n                            value: id\r\n                        }\r\n                    });\r\n\r\n                    self.name = parent;\r\n\r\n                    this.config.call(self, config);\r\n\r\n                    return self;\r\n                }\r\n            },\r\n            assign: {\r\n                value: function () {\r\n                    const self = Object.create(this);\r\n\r\n                    self.index = 0;\r\n                    self.shim = false;\r\n                    self.auto = false;\r\n                    self.handleRotation = true;\r\n                    self.timer = 0;\r\n                    self.delay = slide.defaults.delay;\r\n                    self.scrollIntoViewOptions = {\r\n                        block: \"nearest\",\r\n                        inline: \"start\"\r\n                    };\r\n\r\n                    return self;\r\n                }\r\n            },\r\n            observer: {\r\n                value: function (parent: Element, children: HTMLCollection) {\r\n                    const self = this;\r\n                    return slide.observer(\r\n                        parent,\r\n                        children,\r\n                        function (index: number) {\r\n                            self.setIndex(index);\r\n                            self.setCallback();\r\n                        }\r\n                    );\r\n                }\r\n            },\r\n            getIndex: {\r\n                value: function (index: number) {\r\n                    let result = this.index;\r\n                    const children = this.children.length;\r\n\r\n                    if (typeof index === \"number\") {\r\n                        result = index;\r\n                    }\r\n\r\n                    if (result === children) {\r\n                        result = 0;\r\n                    } else if (result < 0) {\r\n                        result = children - 1;\r\n                    }\r\n\r\n                    return result;\r\n                }\r\n            },\r\n            setIndex: {\r\n                value: function (index: number) {\r\n                    this.index = this.getIndex(index);\r\n                }\r\n            },\r\n            setRotation: {\r\n                value: function () {\r\n                    const item = this.children[this.index];\r\n                    item.scrollIntoView(this.scrollIntoViewOptions);\r\n                }\r\n            },\r\n            isValidNumber: {\r\n                value: function (number: number) {\r\n                    return typeof number === \"number\" && !isNaN(number);\r\n                }\r\n            },\r\n            setDelay: {\r\n                value: function (time: string) {\r\n                    let parseTime = parseInt(time);\r\n\r\n                    const illegal =\r\n                        !this.isValidNumber(parseTime) ||\r\n                        parseTime < slide.defaults.delay;\r\n\r\n                    if (illegal) {\r\n                        parseTime = this.delay;\r\n                    }\r\n\r\n                    this.delay = parseTime;\r\n                }\r\n            },\r\n            setCallback: {\r\n                value: function () {\r\n                    if (typeof this.handleCallback === \"function\") {\r\n                        this.handleCallback(\r\n                            this.index,\r\n                            this.getIndex(this.index - 1),\r\n                            this.getIndex(this.index + 1)\r\n                        );\r\n                    }\r\n                }\r\n            },\r\n            setTimer: {\r\n                value: function (cb) {\r\n                    if (this.auto) {\r\n                        this.timer = setTimeout(cb, this.delay);\r\n                    } else {\r\n                        clearTimeout(this.timer);\r\n                    }\r\n                }\r\n            },\r\n            routeCallback: {\r\n                value: function (cb) {\r\n                    if (this.shim) {\r\n                        this.setCallback(cb);\r\n                    }\r\n                    cb();\r\n                }\r\n            },\r\n            setTask: {\r\n                value: function (index: number) {\r\n                    const self = this;\r\n\r\n                    self.setDelay();\r\n                    self.setIndex(index);\r\n                    if (this.handleRotation) {\r\n                        self.setRotation();\r\n                    }\r\n                    self.routeCallback(function () {\r\n                        self.setTimer(function () {\r\n                            self.setTask(self.index + 1);\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        })\r\n    },\r\n    api: {\r\n        value: generate({\r\n            parent: {\r\n                set: function (parent) {\r\n                    this.validateNodeElement(parent);\r\n\r\n                    const worker = slide.request(this.id);\r\n\r\n                    worker.id = this.id;\r\n                    worker.parent = parent;\r\n                    worker.observe = worker.observer(\r\n                        worker.parent,\r\n                        parent.children\r\n                    );\r\n\r\n                    this.children = parent.children;\r\n                },\r\n                get: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.parent;\r\n                }\r\n            },\r\n            validateNodeElement: {\r\n                value: function (element) {\r\n                    if (typeof element !== \"object\") {\r\n                        this.getError(\"ERR-E\");\r\n                    }\r\n                    if (element === null) {\r\n                        this.getError(\"ERR-P\");\r\n                    }\r\n                    if (element.nodeType !== 1) {\r\n                        this.getError(\"ERR-N\");\r\n                    }\r\n                    return true;\r\n                }\r\n            },\r\n            toArray: {\r\n                value: toArray\r\n            },\r\n            children: {\r\n                set: function () {\r\n                    const worker = slide.request(this.id);\r\n                    worker.children = worker.parent.children;\r\n                    worker.observe(worker.children);\r\n                },\r\n                get: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.children;\r\n                }\r\n            },\r\n            isAuto: {\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.auto;\r\n                }\r\n            },\r\n            setAuto: {\r\n                value: function (status: boolean) {\r\n                    const worker = slide.request(this.id);\r\n                    if (typeof status === \"boolean\") {\r\n                        worker.auto = status;\r\n                    }\r\n                }\r\n            },\r\n            setScrollIntoView: {\r\n                value: function (options: ScrollIntoViewOptions) {\r\n                    const worker = slide.request(this.id);\r\n                    if (\r\n                        typeof options === \"object\" ||\r\n                        typeof options === \"boolean\"\r\n                    ) {\r\n                        worker.scrollIntoViewOptions = options;\r\n                    }\r\n                }\r\n            },\r\n            watch: {\r\n                value: function (task) {\r\n                    const worker = slide.request(this.id);\r\n                    worker.handleCallback = task.bind(this);\r\n\r\n                    if (!(\"IntersectionObserver\" in window)) {\r\n                        worker.setCallback();\r\n                    }\r\n                }\r\n            },\r\n            countChildren: {\r\n                value: function () {\r\n                    return this.children.length;\r\n                }\r\n            },\r\n            getDelay: {\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.delay;\r\n                }\r\n            },\r\n            setDelay: {\r\n                value: function (delay: string) {\r\n                    const worker = slide.request(this.id);\r\n                    worker.setDelay(delay);\r\n                }\r\n            },\r\n            setError: {\r\n                value: function (code: string, message: string) {\r\n                    if (\r\n                        typeof code === \"string\" &&\r\n                        typeof message === \"string\"\r\n                    ) {\r\n                        Object.defineProperty(slide.errors, code, {\r\n                            value: message\r\n                        });\r\n                    } else {\r\n                        this.getError(\"ERR-M\");\r\n                    }\r\n                }\r\n            },\r\n            getError: {\r\n                value: function (code: string) {\r\n                    if (typeof code !== \"string\") {\r\n                        code = \"ERR-C\";\r\n                    }\r\n\r\n                    const error = slide.errors[code] || slide.defaults.error;\r\n                    const help = slide.docs.error;\r\n                    const message = code + \": \" + error + \" / \" + help;\r\n                    throw message;\r\n                }\r\n            },\r\n            hasError: {\r\n                value: function (code: string) {\r\n                    return slide.errors.hasOwnProperty(code);\r\n                }\r\n            },\r\n            config: {\r\n                value: function (options: {}) {\r\n                    const worker = slide.request(this.id);\r\n                    worker.config.call(this, options);\r\n                }\r\n            },\r\n            setShim: {\r\n                enumerable: true,\r\n                value: function (status: boolean) {\r\n                    const worker = slide.request(this.id);\r\n\r\n                    if (typeof status === \"boolean\") {\r\n                        worker.shim = status;\r\n                    }\r\n                }\r\n            },\r\n            play: {\r\n                enumerable: true,\r\n                value: function (persistCurrentIndex?: boolean) {\r\n                    const worker = slide.request(this.id);\r\n                    const index =\r\n                        typeof persistCurrentIndex === \"boolean\" &&\r\n                        persistCurrentIndex\r\n                            ? worker.index\r\n                            : worker.index + 1;\r\n\r\n                    this.pause();\r\n                    worker.auto = true;\r\n                    worker.setTask(index);\r\n                }\r\n            },\r\n            pause: {\r\n                enumerable: true,\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    worker.auto = false;\r\n                    clearTimeout(worker.timer);\r\n                }\r\n            },\r\n            prev: {\r\n                enumerable: true,\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    this.pause();\r\n                    worker.setTask(worker.index - 1);\r\n                }\r\n            },\r\n            next: {\r\n                enumerable: true,\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    this.pause();\r\n                    worker.setTask(worker.index + 1);\r\n                }\r\n            },\r\n            prevIndex: {\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.getIndex(worker.index - 1);\r\n                }\r\n            },\r\n            nextIndex: {\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.getIndex(worker.index + 1);\r\n                }\r\n            },\r\n            currentIndex: {\r\n                value: function () {\r\n                    const worker = slide.request(this.id);\r\n                    return worker.index;\r\n                }\r\n            },\r\n            getIndex: {\r\n                value: function (index: number) {\r\n                    if (typeof index !== \"number\") {\r\n                        this.getError(\"ERR-X\");\r\n                    }\r\n\r\n                    const worker = slide.request(this.id);\r\n                    return worker.getIndex(index);\r\n                }\r\n            },\r\n            setIndex: {\r\n                value: function (index: number) {\r\n                    if (typeof index !== \"number\") {\r\n                        this.getError(\"ERR-X\");\r\n                    }\r\n\r\n                    const worker = slide.request(this.id);\r\n                    return worker.setIndex(index);\r\n                }\r\n            },\r\n            handleRotation: {\r\n                value: function (status: boolean) {\r\n                    const worker = slide.request(this.id);\r\n                    if (typeof status === \"boolean\") {\r\n                        worker.handleRotation = status;\r\n                    }\r\n                }\r\n            },\r\n            goto: {\r\n                enumerable: true,\r\n                value: function (index: number) {\r\n                    if (typeof index !== \"number\") {\r\n                        this.getError(\"ERR-X\");\r\n                    }\r\n\r\n                    const worker = slide.request(this.id);\r\n                    this.pause();\r\n                    worker.setIndex(index);\r\n                    worker.setTask();\r\n                }\r\n            }\r\n        })\r\n    },\r\n    interface: {\r\n        value: generate({\r\n            into: {\r\n                value: function (\r\n                    parent: Element,\r\n                    init: SlideIntoTask | Record<string, any>,\r\n                    app: SlideIntoTask | Record<string, any>\r\n                ) {\r\n                    const worker = slide.manager.assign();\r\n                    let task = app;\r\n                    let options = {};\r\n\r\n                    slide.team.push(worker);\r\n\r\n                    if (typeof init === \"function\") {\r\n                        task = init;\r\n                    }\r\n\r\n                    if (typeof init === \"object\") {\r\n                        options = init;\r\n                    } else if (typeof app === \"object\") {\r\n                        options = app;\r\n                    }\r\n\r\n                    const ui = slide.manager.create(\r\n                        slide.api,\r\n                        slide.team.length - 1,\r\n                        parent,\r\n                        options\r\n                    );\r\n\r\n                    return task.call(ui, ui);\r\n                }\r\n            },\r\n            proto: {\r\n                value: function (parameters: Record<string, any>) {\r\n                    if (typeof parameters === \"object\") {\r\n                        Object.create(slide.api, parameters);\r\n                        Object.keys(parameters).forEach(function (parameter) {\r\n                            Object.defineProperty(slide.api, parameter, {\r\n                                writable: false,\r\n                                configurable: false,\r\n                                enumerable: true,\r\n                                value: parameters[parameter]\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n});\r\n\r\nexport const Slide = slide.interface;\r\n\r\nexport default Slide;\r\n","import Slide from \"Shared/ts/api/carousel/slide/slide\";\r\nimport { ISlide } from \"Shared/ts/interfaces/carousel/slide/slide\";\r\nimport ICarousel from \"Shared/ts/interfaces/carousel/carousel\";\r\nimport { elementExists } from \"Shared/ts/utils/html\";\r\n\r\nexport default class SlideCarouselAdapter implements ICarousel {\r\n    public api: ISlide | undefined;\r\n    public container: Element | undefined;\r\n    public parent: Element | undefined;\r\n    public children: HTMLCollection | undefined;\r\n\r\n    /**\r\n     * An adapter Api that implements the ICarousel contract while communicating with the Slide Js Api\r\n     * @param container Element\r\n     */\r\n    constructor(container: Element) {\r\n        this.container = container;\r\n        this.api = this.create(container);\r\n\r\n        this.parent = this.api?.parent;\r\n        this.children = this.api?.children;\r\n    }\r\n\r\n    public create(element: Element) {\r\n        let result: ISlide | undefined;\r\n\r\n        if (elementExists(element)) {\r\n            const id = element.querySelector('[id][class*=\"slide__into\"]');\r\n\r\n            if (elementExists(id)) {\r\n                result = Slide.into(\r\n                    id,\r\n                    {\r\n                        root: element\r\n                    },\r\n                    (api: ISlide) => {\r\n                        api.root?.classList.add(\"slide--is-ready\");\r\n\r\n                        return api;\r\n                    }\r\n                );\r\n            } else {\r\n                console.error({\r\n                    message: `An element requires the class name 'slide__into' and requires an id attribute. No element was found from the container element context.`,\r\n                    element\r\n                });\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public isAuto() {\r\n        return this.api?.isAuto() ?? false;\r\n    }\r\n\r\n    public setAuto(status: boolean) {\r\n        this.api?.setAuto(status);\r\n    }\r\n\r\n    public play(persistCurrentIndex?: boolean) {\r\n        this.api?.play(persistCurrentIndex);\r\n    }\r\n\r\n    public pause() {\r\n        this.api?.pause();\r\n    }\r\n\r\n    public prev() {\r\n        this.api?.prev();\r\n    }\r\n\r\n    public next() {\r\n        this.api?.next();\r\n    }\r\n\r\n    public goto(index: number) {\r\n        this.api?.goto(index);\r\n    }\r\n\r\n    public watch(\r\n        task: (\r\n            currentIndex: number,\r\n            previousIndex: number,\r\n            nextIndex: number\r\n        ) => void\r\n    ) {\r\n        this.api?.watch(task);\r\n    }\r\n\r\n    public nextIndex() {\r\n        return this.api?.nextIndex();\r\n    }\r\n\r\n    public currentIndex() {\r\n        return this.api?.currentIndex();\r\n    }\r\n\r\n    public prevIndex() {\r\n        return this.api?.prevIndex();\r\n    }\r\n\r\n    public countChildren() {\r\n        return this.api?.countChildren();\r\n    }\r\n\r\n    public getDelay() {\r\n        return this.api?.getDelay();\r\n    }\r\n\r\n    public setDelay(delay: number) {\r\n        return this.api?.setDelay(delay);\r\n    }\r\n\r\n    public getIndex(index: number) {\r\n        return this.api?.getIndex(index);\r\n    }\r\n\r\n    public setIndex(index: number) {\r\n        this.api?.setIndex(index);\r\n    }\r\n}\r\n","import IFadeCarousel from \"Shared/ts/interfaces/carousel/fade-carousel\";\r\nimport SlideCarouselAdapter from \"Shared/ts/api/carousel/slide/adapters/slide-carousel\";\r\n\r\nexport default class FadeSlideCarouselAdapter\r\n    extends SlideCarouselAdapter\r\n    implements IFadeCarousel\r\n{\r\n    /**\r\n     * An adapter Api that implements the IFadeCarousel contract while communicating with the Slide Js Api\r\n     * @param container Element\r\n     */\r\n    constructor(container: Element) {\r\n        super(container);\r\n    }\r\n\r\n    /**\r\n     * Disables the Carousel's auto-scroll rotation behavior and enables shim mode\r\n     */\r\n    public initialize() {\r\n        this.api?.setShim(true);\r\n        this.api?.handleRotation(false);\r\n    }\r\n}\r\n","// components\nimport FadeCarousel from \"Shared/ts/components/fade-carousel\";\n\n// adapters\nimport FadeSlideCarouselAdapter from \"Shared/ts/api/carousel/slide/adapters/fade-slide-carousel\";\n\n// observers\nimport { observer } from \"Shared/ts/observers/intersection\";\nobserver(\".slide--fade\", {\n  inRange: element => {\n    const carousel = new FadeCarousel(new FadeSlideCarouselAdapter(element));\n    carousel.enablePrevNextControls();\n  }\n});"],"names":["document","createElement","elementExists","element","body","contains","head","enumerateElements","elements","slice","call","observer","selector","config","loadItems","querySelectorAll","window","loadItemObserver","IntersectionObserver","entries","forEach","entry","intersectionRatio","isIntersecting","inRange","target","unObserve","unobserve","outRange","options","loadItem","observe","observeByApi","active","process","setTimeout","getBoundingClientRect","top","innerHeight","bottom","style","display","inView","filter","image","length","removeEventListener","addEventListener","observeByBoundingClientRect","Carousel","constructor","context","container","this","baseInitialize","observeContainer","carousel","set","events","watch","push","name","get","event","handler","currentIndex","prevIndex","nextIndex","on","off","result","find","index","indexOf","splice","getAttribute","processAttributes","JSON","parse","error","console","warn","setAttributes","dataset","carouselConfig","stringify","auto","setAuto","delay","setDelay","updateAttributes","MutationObserver","mutationRecords","attributes","goto","getContext","play","persistCurrentIndex","pause","next","prev","autoplay","self","id","parent","rangeControl","record","threshold","enablePrevNextControls","prevButton","querySelector","nextButton","bind","enablePlayPauseControls","playButton","pauseButton","thumbnailButton","thumbnailButtons","previousButton","classList","currentThumbnailCSSClassName","remove","add","parseInt","thumbnails","has","currentButton","updateThumbnailNavigationMarker","enableThumbnailControls","eventCallback","updateThumbnailNavigation","undefined","updateThumbnailNavigationMarkerByIndex","WeakMap","controls","FadeCarousel","super","initialize","children","createWatch","setSlideToCurrent","item","counter","countChildren","updateCurrentSlide","setIndex","slide","previousSlide","currentSlideCSSClassName","generate","properties","o","Object","defineProperties","toArray","collection","Array","from","defaults","value","noScroll","docs","errors","team","request","cb","hasOwnProperty","io","root","rootMargin","shim","manager","keys","option","defineProperty","enumerable","create","api","assign","handleRotation","timer","scrollIntoViewOptions","block","inline","setCallback","getIndex","setRotation","scrollIntoView","isValidNumber","number","isNaN","time","parseTime","handleCallback","setTimer","clearTimeout","routeCallback","setTask","validateNodeElement","worker","getError","nodeType","isAuto","status","setScrollIntoView","task","getDelay","setError","code","message","hasError","setShim","interface","into","init","app","ui","proto","parameters","parameter","writable","configurable","SlideCarouselAdapter","Slide","FadeSlideCarouselAdapter"],"sourceRoot":""}